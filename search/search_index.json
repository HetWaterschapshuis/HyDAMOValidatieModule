{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome HyDAMO Validation","text":"<p>The HyDAMO Validation Module is used to validate HyDAMO data.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#111","title":"1.1.1","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>changelog.md in documentation </li> <li>validation.log in data_dir</li> <li>more extensive logging: info which logical-rule is executed</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Specification of python and package versions in environment.yml's: HYV-167</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>logical-validation: validation-ruleset is cleaned prior to iteration of rules; only rules will be executed on existing layers (avoiding crashes): HYV-187</li> </ul>"},{"location":"guides/contribute/","title":"Contribute","text":"<p>For doing contributions you:</p> <ul> <li>have your own GitHub account</li> <li>work with GitHub Desktop or work-round with Git</li> <li>can work with GeoPandas and Pytest</li> </ul> <p>We are very happy with contributions that are:</p> <ol> <li>written similar to existing code (e.g. use of GeoPandas)</li> <li>provided with docstrings so it can be documented</li> <li>tested with Pytest</li> </ol> <p>You can make a contribution in the following steps:</p> <ol> <li>Development installation</li> <li>Fork and clone and install a copy</li> <li>Add and test new code</li> <li>Commit your copy and request a merge</li> </ol> <p>The remainder of this guide explains how to do it.</p>"},{"location":"guides/contribute/#dev-installation","title":"Dev installation","text":""},{"location":"guides/contribute/#setup-environment","title":"Setup environment","text":"<p>Use the <code>env/dev_environment.yml</code> in the repository to create the conda environment <code>validatietool</code> with all required packages</p> <pre><code>conda env create -f dev_environment.yml\n</code></pre> <p>After installation you can activate your environment in command prompt</p>"},{"location":"guides/contribute/#fork-repo","title":"Fork repo","text":"<p>Fork the respository to your own GitHub account:</p> <ol> <li>Click <code>fork</code> in the upper-right of the rository.</li> <li>Select your own github account</li> </ol> <p>The repository is now available on your own github account:</p> <p></p>"},{"location":"guides/contribute/#clone-repo","title":"Clone repo","text":"<p>Now clone your fork to your local drive. We do this with GitHub Desktop. After installation and authentication you can get a local copy by:</p> <ol> <li><code>Add</code> and <code>Clone repository...</code> in the top-left corner</li> <li>Find your fork and clone it to an empty directory on your local drive</li> <li>Press  clone`</li> </ol> <p></p> <p>Verify if the repository is on your local drive. </p>"},{"location":"guides/contribute/#install-copy","title":"Install copy","text":"<p>Install the module in the activated <code>validatietool</code> environment in develop-mode:</p> <pre><code>pip install -e .\n</code></pre> <p>Now you're good to go!</p>"},{"location":"guides/contribute/#improve-code","title":"Improve code","text":"<p>Imagine we want to be able to multiply an HyDAMO attribute by a constant value or a value in an other attribute. Therefore we will add a function <code>multiply</code> to the general functions</p>"},{"location":"guides/contribute/#add-code","title":"Add code","text":"<p>In functions.general.py we add our new function:</p> <pre><code>def multiply(gdf, left, right):\n    \"\"\"\n    Multiply 'left' with 'right'\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        Input GeoDataFrame\n    left : str, numeric\n        Left column or value in expression\n    right : str, numeric\n        Right column or value in expression\n\n    Returns\n    -------\n    result : Series\n        Float series\n\n    \"\"\"\n    expression = \" * \".join(map(str, [left, right]))\n    return gdf.eval(expression)\n\n</code></pre> <p>Please note the use of numpy docstrings. These are required as they are later translated to documentation.</p> <p>Also note we use GeoPandas GeoDataFrames specified by the input variable <code>gdf</code>. Please make your code fast and efficient by the use of in-build methods. Above we use <code>gdf.eval(expression)</code> by example.</p> <p>In complex cases you can use <code>gdf.apply(lambda x: _a_function_for_every_row(row, *args, **kwargs), axis=1)</code> to apply a function on every <code>row</code> in your GeoDataFrame. Here <code>*args</code> and <code>**kwargs</code> refer to extra input arguments. In <code>functions.topologic.py</code> and <code>functions.logic.py</code> you can find numerous examples.</p>"},{"location":"guides/contribute/#test-code","title":"Test code","text":"<p>In the test-folder we add a test. In this case we can add it to <code>tests.general_functions_test.py</code>:</p> <pre><code>def test_multiply():\n    _gdf = gpd.GeoDataFrame(data={\"left\": [1, 2, 3],\n                                  \"right\": [4, 5, 6],\n                                  \"geometry\": [None, None, None]})\n    expected_result = [4, 10, 18]\n    result = general_functions.multiply(_gdf, left=\"left\", right=\"right\").to_list()\n    assert result == expected_result\n</code></pre> <p>A test-function starts with <code>test_</code>. In within the test-function you confirm if your new functionity is correct with <code>assert = True</code>. In this case we check if the <code>result</code> of our function is the same as our <code>expected_result</code></p> <p>Within your activated environment you can test your function with pytest:</p> <pre><code>pytest --cov-report term-missing --cov=hydamo_validation tests/\n</code></pre> <p>As your function is correct, the test should not fail. You can confirm all lines of your new code are tested: </p>"},{"location":"guides/contribute/#contribute_1","title":"Contribute","text":""},{"location":"guides/contribute/#commit","title":"Commit","text":"<p>First commit your new function in your own repository:</p> <p></p>"},{"location":"guides/contribute/#request-a-merge","title":"Request a merge","text":"<p>Now request a merge:</p> <p></p>"},{"location":"guides/get_started/","title":"Installation","text":""},{"location":"guides/get_started/#install-anaconda-or-miniconda","title":"Install Anaconda or Miniconda","text":"<p>Make sure you have an Miniconda or Anaconda installation. You can download these here:  - https://www.anaconda.com/products/individual  - https://docs.conda.io/en/latest/miniconda.html</p> <p>During installation, tick the box \"Add Anaconda to PATH\", ignore the red remarks</p>"},{"location":"guides/get_started/#create-the-validatietool-environment","title":"Create the <code>validatietool</code> environment","text":"<p>Use the <code>env/environment.yml</code> in the repository to create the conda environment: <code>validatietool</code></p> <pre><code>conda env create -f environment.yml\n</code></pre> <p>After installation you can activate your environment in command prompt</p> <pre><code>conda activate validatietool\n</code></pre>"},{"location":"guides/get_started/#install-hydamo_validation","title":"Install hydamo_validation","text":"<p>Download or clone the repository. Now simply install the module in the activated environment:</p> <pre><code>pip install .\n</code></pre>"},{"location":"guides/get_started/#run-an-example","title":"Run an example","text":"<p>A working example with data can be found in <code>notebooks/test_wrij.ipynb</code>. In the activated environment launch jupyter notebook by:</p> <pre><code>jupyter notebook\n</code></pre> <p>Select <code>test_wrij.ipynb</code> read and run it.</p>"},{"location":"guides/release/","title":"Release","text":"<p>Deze handleiding volgt op de handleiding <code>contribute</code> en beschrijft de release-procedure vanuit de main branch.</p>"},{"location":"guides/release/#1-verander-het-versienummer-van-de-module","title":"1. Verander het versienummer van de module","text":"<p>Kies het nieuwe versienummer volgens semantic versioning:</p> <ul> <li>MAJOR: brekende wijzigingen (bijv. <code>1.0.0</code> \u2192 <code>2.0.0</code>)</li> <li>MINOR: nieuwe functionaliteit, achterwaarts compatibel (bijv. <code>1.3.0</code> \u2192 <code>1.4.0</code>)</li> <li>PATCH: bugfixes, kleine wijzigingen (bijv. <code>1.3.2</code> \u2192 <code>1.3.3</code>)</li> </ul> <p>Voorbeeld: huidige versie is <code>1.4.1</code>, je kiest <code>1.4.2</code> omdat we bestaande functionaliteit hebben verbeterd.</p> <p>Zet het versienummer in <code>hydamo_validation/__init__.py</code> achter <code>__version__</code>.</p> <p>Zorg dat alle wijzigingen via Pull Requests zijn gecommit in de main branch</p>"},{"location":"guides/release/#2-testen","title":"2. Testen","text":"<p>Nadat \u00e1lle code voor een nieuwe release is gecommit in de main branch, draai nog 1x alle tests met pytest. In de dev-environment (zie <code>env/dev_environment.yml</code>) is pytest beschikbaar. Run: </p> <p><code>pytest --cov=hydamo_validation tests/</code></p> <p>Publiceer alleen als alle tests slagen: </p>"},{"location":"guides/release/#3-aanmaken-van-een-release","title":"3. Aanmaken van een release","text":"<p>Zorg dat alle wijzigingen via Pull Requests zijn gecommit in de main branch</p> <ol> <li>Ga naar de GitHub-pagina van de repository.</li> <li>Klik op Releases (rechts in de sidebar of onder het tabje \u201cCode\u201d).</li> <li>Klik op <code>Draft a new release</code> (of New release).</li> <li>Kies <code>Tag: Select tag</code> en kies <code>Create new tag</code>. Maak een annotated tag gelijk aan versienummer, dus <code>v.X.Y.Z</code>, bijvoorbeeld <code>v1.4.2</code></li> <li>Laat <code>Target: main</code></li> <li>Zet de tag in de <code>Release title</code>, dus weer <code>vX.Y.Z</code>, dus <code>v1.4.2</code> in het voorbeeld hierboven</li> <li><code>Release notes</code>, klik eventueel <code>Generate release notes</code> en/of beschrijf de belangrijkste wijzigingen:<ul> <li>Nieuwe features</li> <li>Bugfixes</li> <li>Breaking changes</li> </ul> </li> <li>Klik op <code>Publish release</code></li> </ol> <p>Je ziet nu een nieuwe release beschikbaar in GitHub met een <code>afdruk</code> van de code uit de main branch</p>"},{"location":"guides/release/#4-publiceren-op-pypi","title":"4. Publiceren op PyPi","text":"<p>Publiceren doe je in 2 stappen: 1. Bouw distributies met <code>python setup.py sdist</code>  2. Upload naar PyPI <code>twine upload dist/* -p jouw_eigen_twine_password</code></p> <p>De laatste release moet nu ook beschikbaar zijn op https://pypi.org/project/hydamo-validation/ en wordt vanaf nu geinstalleerd met <code>pip install hydamo-validation</code></p>"},{"location":"reference/datasets/","title":"DataSets","text":"<p>ValidationResult to be dumped as json.</p> Source code in <code>hydamo_validation\\datasets.py</code> <pre><code>class DataSets:\n    \"\"\"ValidationResult to be dumped as json.\"\"\"\n\n    def __init__(self, dataset_dir: Union[str, Path]):\n        \"\"\"Initialie datasets.\"\"\"\n        self.path = Path(dataset_dir)\n        self.properties: Dict = {}\n\n        self._set_properties()\n\n    def _set_properties(self):\n        dataset_files = self.path.glob(\"*.gpkg\")\n\n        for gpkg in dataset_files:\n            layers = fiona.listlayers(gpkg)\n            layers_dict = {}\n            for layer in layers:\n                with fiona.open(gpkg, layer=layer) as src:\n                    schema = normalize_fiona_schema(src.schema)\n                    layers_dict[layer] = schema\n\n            self.properties[gpkg.name] = layers_dict\n\n    def _filter_status(self, gdf, status_object):\n        if status_object is not None:\n            if \"statusobject\" in gdf.columns:\n                # gdf = gdf.loc[gdf[\"statusobject\"].isin(status_object)]\n                gdf = gdf.loc[\n                    np.where(\n                        gdf[\"statusobject\"].isna()\n                        | gdf[\"statusobject\"].isin(status_object)\n                    )\n                ]\n        return gdf\n\n    @property\n    def layers(self):\n        \"\"\"Return the layers in the datasets.\"\"\"\n        dataset_layers_dict = {k: list(v.keys()) for k, v in self.properties.items()}\n\n        layers = [\n            item for sublist in list(dataset_layers_dict.values()) for item in sublist\n        ]\n\n        return layers\n\n    def read_layer(self, layer, result_summary=ResultSummary(), status_object=None):\n        \"\"\"\n        Read a layer from the dataset.\n\n        Parameters\n        ----------\n        layer : str\n            Name of the layer (case sensitive!)\n        result_summary : ResultSummary\n            A hydamo_validation ResultSummary class where a possible exception\n            will be appended to.\n        status_object : List[str], optional\n            A list of statusobject values used as a filter. The default is None.\n\n        Raises\n        ------\n        e\n            General exception while reading the layer from the geopackage.\n        KeyError\n            Specific exception; the layer is not part of the geopackage.\n\n        Returns\n        -------\n        gdf : GeoDataFrame\n            GeoDataFrame read from datasets (all columns are converted to lower case)\n        schema : TYPE\n            Fiona schema read from the layer\n        \"\"\"\n\n        if layer in self.layers:\n            dataset = {k: v for k, v in self.properties.items() if layer in v.keys()}\n            file_path = self.path.joinpath(list(dataset.keys())[0])\n            schema = list(dataset.values())[0][layer]\n            try:\n                gdf = read_geopackage(file_path, layer=layer)\n                gdf = self._filter_status(gdf, status_object)\n            except Exception as e:\n                result_summary.append_warning(\n                    (\n                        f\"Laag {layer} uit bestand {file_path.name} is geen \"\n                        \"GeoPackage die wij kunnen openen. Vervang het bestand en \"\n                        \"probeer opnieuw.\"\n                    )\n                )\n                raise e\n\n            # we will read all lower case\n            schema[\"properties\"] = {\n                k.lower(): v for k, v in schema[\"properties\"].items()\n            }\n            gdf.columns = [i.lower() for i in gdf.columns]\n        else:\n            raise KeyError(f\"'{layer}' not in dataset-layers: '{self.layers}'\")\n\n        return gdf, schema\n</code></pre>"},{"location":"reference/datasets/#hydamo_validation.datasets.DataSets.layers","title":"<code>layers</code>  <code>property</code>","text":"<p>Return the layers in the datasets.</p>"},{"location":"reference/datasets/#hydamo_validation.datasets.DataSets.__init__","title":"<code>__init__(dataset_dir)</code>","text":"<p>Initialie datasets.</p> Source code in <code>hydamo_validation\\datasets.py</code> <pre><code>def __init__(self, dataset_dir: Union[str, Path]):\n    \"\"\"Initialie datasets.\"\"\"\n    self.path = Path(dataset_dir)\n    self.properties: Dict = {}\n\n    self._set_properties()\n</code></pre>"},{"location":"reference/datasets/#hydamo_validation.datasets.DataSets.read_layer","title":"<code>read_layer(layer, result_summary=ResultSummary(), status_object=None)</code>","text":"<p>Read a layer from the dataset.</p>"},{"location":"reference/datasets/#hydamo_validation.datasets.DataSets.read_layer--parameters","title":"Parameters","text":"<p>layer : str     Name of the layer (case sensitive!) result_summary : ResultSummary     A hydamo_validation ResultSummary class where a possible exception     will be appended to. status_object : List[str], optional     A list of statusobject values used as a filter. The default is None.</p>"},{"location":"reference/datasets/#hydamo_validation.datasets.DataSets.read_layer--raises","title":"Raises","text":"<p>e     General exception while reading the layer from the geopackage. KeyError     Specific exception; the layer is not part of the geopackage.</p>"},{"location":"reference/datasets/#hydamo_validation.datasets.DataSets.read_layer--returns","title":"Returns","text":"<p>gdf : GeoDataFrame     GeoDataFrame read from datasets (all columns are converted to lower case) schema : TYPE     Fiona schema read from the layer</p> Source code in <code>hydamo_validation\\datasets.py</code> <pre><code>def read_layer(self, layer, result_summary=ResultSummary(), status_object=None):\n    \"\"\"\n    Read a layer from the dataset.\n\n    Parameters\n    ----------\n    layer : str\n        Name of the layer (case sensitive!)\n    result_summary : ResultSummary\n        A hydamo_validation ResultSummary class where a possible exception\n        will be appended to.\n    status_object : List[str], optional\n        A list of statusobject values used as a filter. The default is None.\n\n    Raises\n    ------\n    e\n        General exception while reading the layer from the geopackage.\n    KeyError\n        Specific exception; the layer is not part of the geopackage.\n\n    Returns\n    -------\n    gdf : GeoDataFrame\n        GeoDataFrame read from datasets (all columns are converted to lower case)\n    schema : TYPE\n        Fiona schema read from the layer\n    \"\"\"\n\n    if layer in self.layers:\n        dataset = {k: v for k, v in self.properties.items() if layer in v.keys()}\n        file_path = self.path.joinpath(list(dataset.keys())[0])\n        schema = list(dataset.values())[0][layer]\n        try:\n            gdf = read_geopackage(file_path, layer=layer)\n            gdf = self._filter_status(gdf, status_object)\n        except Exception as e:\n            result_summary.append_warning(\n                (\n                    f\"Laag {layer} uit bestand {file_path.name} is geen \"\n                    \"GeoPackage die wij kunnen openen. Vervang het bestand en \"\n                    \"probeer opnieuw.\"\n                )\n            )\n            raise e\n\n        # we will read all lower case\n        schema[\"properties\"] = {\n            k.lower(): v for k, v in schema[\"properties\"].items()\n        }\n        gdf.columns = [i.lower() for i in gdf.columns]\n    else:\n        raise KeyError(f\"'{layer}' not in dataset-layers: '{self.layers}'\")\n\n    return gdf, schema\n</code></pre>"},{"location":"reference/general_functions/","title":"Topologic functions","text":"<p>functions to be executed on gdf.</p>"},{"location":"reference/general_functions/#hydamo_validation.general_functions.buffer","title":"<code>buffer(gdf, radius, percentile, coverage='ahn', fill_value=None)</code>","text":"<p>Percentile of coverage-value of an area defined by a radius around the object</p>"},{"location":"reference/general_functions/#hydamo_validation.general_functions.buffer--parameters","title":"Parameters","text":"<p>gdf : GeoDataFrame     Input GeoDataFrame radius: str, numeric     Radius around object used to define a cirular area percentile : int     The percentile of the coverage within area around object coverage : str, optional     The coverage to use. The default value is 'ahn' fill_value : float, optional     The fill_value to use when the area is not intersecting the coverage.     The default is None</p>"},{"location":"reference/general_functions/#hydamo_validation.general_functions.buffer--returns","title":"Returns","text":"<p>result : Series     Float series</p> Source code in <code>hydamo_validation\\functions\\general.py</code> <pre><code>def buffer(gdf, radius, percentile, coverage=\"ahn\", fill_value: float = None):\n    \"\"\"\n    Percentile of coverage-value of an area defined by a radius around the\n    object\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        Input GeoDataFrame\n    radius: str, numeric\n        Radius around object used to define a cirular area\n    percentile : int\n        The percentile of the coverage within area around object\n    coverage : str, optional\n        The coverage to use. The default value is 'ahn'\n    fill_value : float, optional\n        The fill_value to use when the area is not intersecting the coverage.\n        The default is None\n\n    Returns\n    -------\n    result : Series\n        Float series\n\n    \"\"\"\n    gdf_out = gdf.copy()\n    gdf_out[\"result\"] = np.nan\n    xmin, ymin, xmax, ymax = gdf_out.total_bounds\n    coverage_path = COVERAGES[coverage]\n\n    index_gdf = gpd.read_file(coverage_path.joinpath(\"index.shp\"))\n\n    for idx, row in index_gdf.cx[xmin:xmax, ymin:ymax].iterrows():\n        try:\n            bathymetrie_raster = coverage_path.joinpath(\n                f'{row[\"bladnr\"].upper()}_CM.tif'\n            )\n\n            gdf_select = gdf_out.loc[\n                gdf_out[\"geometry\"].centroid.within(row[\"geometry\"])\n            ]\n            if not gdf_select.empty:\n                if isinstance(radius, str):\n                    gdf_select.loc[:, (\"geometry\")] = gdf_select.apply(\n                        _buffer_row, args=(radius,), axis=1\n                    )\n                else:\n                    radius = max(radius, 0.5)\n                    gdf_select.loc[:, (\"geometry\")] = gdf_select[\"geometry\"].buffer(\n                        radius\n                    )\n\n                with rasterio.open(bathymetrie_raster, \"r\") as src:\n                    profile = src.profile\n                    raster_data = src.read(1)\n                    affine = src.transform\n                    scale = src.scales[0]\n\n                raster_stats = zonal_stats(\n                    gdf_select,\n                    raster_data,\n                    affine=affine,\n                    stats=f\"percentile_{percentile}\",\n                    nodata=profile[\"nodata\"],\n                    raster_out=True,\n                )\n\n                gdf_out.loc[gdf_select.index.to_list(), \"result\"] = [\n                    np.nan if item is None else round(item * scale, 2)\n                    for item in [\n                        item[f\"percentile_{percentile}\"] for item in raster_stats\n                    ]\n                ]\n        except Exception as e:\n            print(\n                (\n                    f\"bathymetrie: {bathymetrie_raster}\\n\"\n                    f\"indices: {gdf_select.index}\\n\"\n                    f\"geometrien: {gdf_select['geometry']}\"\n                )\n            )\n            raise e\n\n    # fill series if if provided\n    if fill_value is not None:\n        gdf_out.loc[gdf_out[\"result\"].isna(), \"result\"] = fill_value\n\n    return gdf_out[\"result\"]\n</code></pre>"},{"location":"reference/general_functions/#hydamo_validation.general_functions.difference","title":"<code>difference(gdf, left, right, absolute=False)</code>","text":"<p>Difference between 'left' and 'right'</p>"},{"location":"reference/general_functions/#hydamo_validation.general_functions.difference--parameters","title":"Parameters","text":"<p>gdf : GeoDataFrame     Input GeoDataFrame left : str, numeric     Left column or value in expression right : TYPE     Right column or value in expression absolute : bool, optional     Absolute (True) or relative difference (False) to left.     The default is False.</p>"},{"location":"reference/general_functions/#hydamo_validation.general_functions.difference--returns","title":"Returns","text":"<p>result : Series     Float series</p> Source code in <code>hydamo_validation\\functions\\general.py</code> <pre><code>def difference(gdf, left, right, absolute=False):\n    \"\"\"\n    Difference between 'left' and 'right'\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        Input GeoDataFrame\n    left : str, numeric\n        Left column or value in expression\n    right : TYPE\n        Right column or value in expression\n    absolute : bool, optional\n        Absolute (True) or relative difference (False) to left.\n        The default is False.\n\n    Returns\n    -------\n    result : Series\n        Float series\n\n    \"\"\"\n\n    if left in gdf.columns:\n        left = gdf[left]\n    if right in gdf.columns:\n        right = gdf[right]\n    if absolute:\n        result = (left - right).abs()\n    else:\n        result = left - right\n\n    return result\n</code></pre>"},{"location":"reference/general_functions/#hydamo_validation.general_functions.divide","title":"<code>divide(gdf, left, right)</code>","text":"<p>Division of 'left' by 'right'</p>"},{"location":"reference/general_functions/#hydamo_validation.general_functions.divide--parameters","title":"Parameters","text":"<p>gdf : GeoDataFrame     Input GeoDataFrame left : str, numeric     Left column or value in expression right : TYPE     Right column or value in expression</p>"},{"location":"reference/general_functions/#hydamo_validation.general_functions.divide--returns","title":"Returns","text":"<p>result : Series     Float series</p> Source code in <code>hydamo_validation\\functions\\general.py</code> <pre><code>def divide(gdf, left, right):\n    \"\"\"\n    Division of 'left' by 'right'\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        Input GeoDataFrame\n    left : str, numeric\n        Left column or value in expression\n    right : TYPE\n        Right column or value in expression\n\n    Returns\n    -------\n    result : Series\n        Float series\n\n    \"\"\"\n    expression = \" / \".join(map(str, [left, right]))\n    return gdf.eval(expression)\n</code></pre>"},{"location":"reference/general_functions/#hydamo_validation.general_functions.join_parameter","title":"<code>join_parameter(gdf, join_object, join_gdf, join_parameter, fill_value=None)</code>","text":"<p>Joins a parameteer of other object to geodataframe.</p> Source code in <code>hydamo_validation\\functions\\general.py</code> <pre><code>def join_parameter(\n    gdf,\n    join_object: str,\n    join_gdf: gpd.GeoDataFrame,\n    join_parameter: str,\n    fill_value=None,\n):\n    \"\"\"Joins a parameteer of other object to geodataframe.\"\"\"\n    _gdf = gdf.copy()\n\n    _join_gdf = join_gdf.copy()\n    _join_gdf.set_index(\"globalid\", inplace=True)\n    series = _join_gdf[join_parameter]\n    series.name = \"result\"\n    _gdf = _gdf.merge(series, how=\"left\", left_on=f\"{join_object}id\", right_index=True)\n\n    # fill series if if provided\n    if fill_value is not None:\n        _gdf.loc[_gdf[\"result\"].isna(), \"result\"] = fill_value\n\n    return _gdf[\"result\"]\n</code></pre>"},{"location":"reference/general_functions/#hydamo_validation.general_functions.multiply","title":"<code>multiply(gdf, left, right)</code>","text":"<p>Multiply 'left' with 'right'</p>"},{"location":"reference/general_functions/#hydamo_validation.general_functions.multiply--parameters","title":"Parameters","text":"<p>gdf : GeoDataFrame     Input GeoDataFrame left : str, numeric     Left column or value in expression right : str, numeric     Right column or value in expression</p>"},{"location":"reference/general_functions/#hydamo_validation.general_functions.multiply--returns","title":"Returns","text":"<p>result : Series     Float series</p> Source code in <code>hydamo_validation\\functions\\general.py</code> <pre><code>def multiply(gdf, left, right):\n    \"\"\"\n    Multiply 'left' with 'right'\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        Input GeoDataFrame\n    left : str, numeric\n        Left column or value in expression\n    right : str, numeric\n        Right column or value in expression\n\n    Returns\n    -------\n    result : Series\n        Float series\n\n    \"\"\"\n    expression = \" * \".join(map(str, [left, right]))\n    return gdf.eval(expression)\n</code></pre>"},{"location":"reference/general_functions/#hydamo_validation.general_functions.object_relation","title":"<code>object_relation(gdf, related_gdf, code_relation, statistic, related_parameter=None, fill_value=None)</code>","text":"<p>Statistic of related object to geodataframe</p>"},{"location":"reference/general_functions/#hydamo_validation.general_functions.object_relation--parameters","title":"Parameters","text":"<p>gdf : GeoDataFrame     Input GeoDataFrame related_gdf : GeoDataFrame     GeoDataFrame with related attributes code_relation : str     Column in related_gdf used to relate to gdf. Example 'stuwid' statistic : str, options: 'min', 'max', 'sum', 'count'     Statistic to compute over related values related_parameter: str     Column in related_gdf over which the statistic is to be computed fill_value : float, optional     The fill_value to use when the area is not intersecting the coverage.     The default is None</p>"},{"location":"reference/general_functions/#hydamo_validation.general_functions.object_relation--returns","title":"Returns","text":"<p>result : Series     Float series</p> Source code in <code>hydamo_validation\\functions\\general.py</code> <pre><code>def object_relation(\n    gdf,\n    related_gdf: gpd.GeoDataFrame,\n    code_relation: str,\n    statistic: Literal[\"min\", \"max\", \"sum\", \"count\"],\n    related_parameter: str = None,\n    fill_value=None,\n):\n    \"\"\"\n    Statistic of related object to geodataframe\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        Input GeoDataFrame\n    related_gdf : GeoDataFrame\n        GeoDataFrame with related attributes\n    code_relation : str\n        Column in related_gdf used to relate to gdf. Example 'stuwid'\n    statistic : str, options: 'min', 'max', 'sum', 'count'\n        Statistic to compute over related values\n    related_parameter: str\n        Column in related_gdf over which the statistic is to be computed\n    fill_value : float, optional\n        The fill_value to use when the area is not intersecting the coverage.\n        The default is None\n\n    Returns\n    -------\n    result : Series\n        Float series\n\n    \"\"\"\n\n    gdf_out = gdf.copy()\n\n    # remove NaN values in from related_gdf[related_parameter]\n    if related_parameter:\n        if \"geometry\" in related_parameter:\n            related_gdf[related_parameter] = _get_geometric_attribute(\n                related_gdf, related_parameter\n            )\n        related_gdf = related_gdf.loc[related_gdf[related_parameter].notna()]\n\n    # compute statistic\n    if statistic == \"count\":\n        series = related_gdf.groupby(by=[code_relation])[code_relation].count()\n    elif statistic == \"sum\":\n        series = related_gdf.groupby(by=[code_relation])[related_parameter].sum()\n    elif statistic == \"min\":\n        series = related_gdf.groupby(by=[code_relation])[related_parameter].min()\n    elif statistic == \"max\":\n        series = related_gdf.groupby(by=[code_relation])[related_parameter].max()\n    elif statistic == \"majority\":\n        series = related_gdf.groupby(by=[code_relation])[related_parameter].agg(\n            pd.Series.mode\n        )\n\n    # join series with gdf\n    series.name = \"result\"\n    series = pd.DataFrame(series.loc[series.index.isin(gdf[\"globalid\"])]).reset_index()\n    gdf_out = gdf_out.merge(\n        series, how=\"left\", left_on=\"globalid\", right_on=code_relation\n    )\n\n    # fill series if if provided\n    if fill_value is not None:\n        gdf_out.loc[gdf_out[\"result\"].isna(), \"result\"] = fill_value\n    return gdf_out[\"result\"]\n</code></pre>"},{"location":"reference/general_functions/#hydamo_validation.general_functions.sum","title":"<code>sum(gdf, array)</code>","text":"<p>Return a sum expression.</p> Source code in <code>hydamo_validation\\functions\\general.py</code> <pre><code>def sum(gdf, array: list):\n    \"\"\"Return a sum expression.\"\"\"\n    expression = \" + \".join(map(str, array))\n    return gdf.eval(expression)\n</code></pre>"},{"location":"reference/hydamo/","title":"HyDAMO datamodel","text":"<p>Definition of the HyDAMO datamodel.</p> Source code in <code>hydamo_validation\\datamodel.py</code> <pre><code>class HyDAMO:\n    \"\"\"Definition of the HyDAMO datamodel.\"\"\"\n\n    def __init__(\n        self,\n        version: str = \"2.2\",\n        schemas_path: Path = SCHEMAS_DIR,\n        ignored_layers: list[str] = [\n            \"afvoeraanvoergebied\",\n            \"imwa_geoobject\",\n            \"leggerwatersysteem\",\n            \"leggerwaterveiligheid\",\n            \"waterbeheergebied\",\n        ],\n    ):\n        self.version = version\n        self.schema_json = schemas_path.joinpath(f\"HyDAMO_{version}.json\")\n        self.layers: list[str] = []\n        self.ignored_layers = ignored_layers\n\n        self.init_datamodel()\n\n    @property\n    def data_layers(self):\n        return [layer for layer in self.layers if not getattr(self, layer).empty]\n\n    def init_datamodel(self) -&gt; None:\n        \"\"\"Initialize DataModel from self.schemas_path.\"\"\"\n        self.validation_schemas: dict[str, Any] = {}\n\n        # read schema as dict\n        with open(self.schema_json) as src:\n            schema = json.load(src)\n            hydamo_layers = [\n                Path(i[\"$ref\"]).name for i in schema[\"properties\"][\"HyDAMO\"][\"anyOf\"]\n            ]\n            self.layers = [i for i in hydamo_layers if i not in self.ignored_layers]\n\n        for hydamo_layer in self.layers:\n            definition = schema[\"definitions\"][hydamo_layer][\"properties\"]\n            layer_schema = map_definition(definition)\n            self.validation_schemas[hydamo_layer] = layer_schema\n\n            # add layer to data_model\n            geotype = next(\n                (i[\"dtype\"] for i in layer_schema if i[\"id\"] == \"geometry\"), None\n            )\n\n            required_columns = [\n                i[\"id\"]\n                for i in [i for i in layer_schema if \"required\" in i.keys()]\n                if i[\"required\"]\n            ]\n\n            setattr(\n                self,\n                hydamo_layer,\n                ExtendedGeoDataFrame(\n                    validation_schema=layer_schema,\n                    layer_name=hydamo_layer,\n                    geotype=geotype,\n                    required_columns=required_columns,\n                ),\n            )\n\n    def get(self, layer: str, global_id: str):\n        \"\"\"\n        Get a DataFrame row (feature) providing a layer an global_id.\n\n        Parameters\n        ----------\n        layer : str\n            DESCRIPTION.\n        global_id : str\n            DESCRIPTION.\n\n        Returns\n        -------\n        TYPE\n            DESCRIPTION.\n\n        \"\"\"\n        return getattr(self, layer).set_index(\"globalid\").loc[global_id]\n\n    def set_data(\n        self,\n        gdf,\n        layer,\n        index_col=None,\n        check_columns=True,\n        check_geotype=True,\n        extra_attributes={},\n    ):\n        \"\"\"\n\n\n        Parameters\n        ----------\n        gdf : GeoDataFrame\n            GeoDataFrame with a HyDAMO object-layer\n        layer : TYPE\n            HyDAMO layer to be set\n        index_col : str, optional\n            Column to be used as index. The default is None.\n        check_columns : bool, optional\n            Check if all required columns are present in the GeoDataFrame.\n            The default is True.\n        check_geotype : bool, optional\n            Check if the geometry is of the required type. The default is True.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n\n        getattr(self, layer).set_data(\n            gdf,\n            index_col=index_col,\n            check_columns=check_columns,\n            check_geotype=check_geotype,\n            extra_attributes={},\n        )\n\n    def to_geopackage(self, file_path, use_schema=True):\n        \"\"\"\n\n        Parameters\n        ----------\n        file_path : path-string\n            Path-string where the file should be written to\n        use_schema : bool, optional\n            Use the schema to specify column-properties The default is True.\n\n        Returns\n        -------\n        None.\n\n        \"\"\"\n        file_path = Path(file_path)\n        for layer in self.layers:\n            gdf = getattr(self, layer).copy()\n            if not gdf.empty:\n                if use_schema:\n                    # match fiona layer schema keys with gdf.columns\n                    schema = getattr(self, layer)._get_schema()\n                    schema_cols = list(schema[\"properties\"].keys()) + [\"geometry\"]\n                    drop_cols = [i for i in gdf.columns if i not in schema_cols]\n                    gdf.drop(columns=drop_cols, inplace=True)\n\n                    schema[\"properties\"] = {\n                        k: v\n                        for k, v in schema[\"properties\"].items()\n                        if k in gdf.columns\n                    }\n\n                    # write gdf to geopackage, including schema\n                    if gdf.index.name in gdf.columns:\n                        gdf.reset_index(drop=True, inplace=True)\n                    gdf.to_file(\n                        file_path,\n                        layer=layer,\n                        driver=\"GPKG\",\n                        engine=\"pyogrio\",\n                    )\n                else:\n                    # write gdf to geopackage as is\n                    if gdf.index.name in gdf.columns:\n                        gdf = gdf.reset_index(drop=True).copy()\n                    gdf.to_file(file_path, layer=layer, driver=\"GPKG\", engine=\"pyogrio\")\n        if file_path.is_file():\n            add_styles_to_geopackage(file_path)\n\n    @classmethod\n    def from_geopackage(\n        cls, file_path, version=\"2.2\", check_columns=True, check_geotype=True\n    ):\n        \"\"\"\n        Initialize HyDAMO class from GeoPackage\n\n        Parameters\n        ----------\n        file_path : path-string\n            Path-string to the hydamo GeoPackage\n        check_columns : bool, optional\n            Check if all required columns are present in the GeoDataFrame.\n            The default is True.\n        check_geotype : bool, optional\n            Check if the geometry is of the required type. The default is True.\n\n        Returns\n        -------\n        hydamo : HyDAMO\n            HyDAMO object initialized with content of GeoPackage\n\n        \"\"\"\n        hydamo = cls(version=version)\n        for layer in fiona.listlayers(file_path):\n            if layer in hydamo.layers:\n                hydamo_layer = getattr(hydamo, layer)\n                hydamo_layer.set_data(\n                    gpd.read_file(file_path, layer=layer),\n                    check_columns=check_columns,\n                    check_geotype=check_geotype,\n                )\n        return hydamo\n</code></pre>"},{"location":"reference/hydamo/#hydamo_validation.datamodel.HyDAMO.from_geopackage","title":"<code>from_geopackage(file_path, version='2.2', check_columns=True, check_geotype=True)</code>  <code>classmethod</code>","text":"<p>Initialize HyDAMO class from GeoPackage</p>"},{"location":"reference/hydamo/#hydamo_validation.datamodel.HyDAMO.from_geopackage--parameters","title":"Parameters","text":"<p>file_path : path-string     Path-string to the hydamo GeoPackage check_columns : bool, optional     Check if all required columns are present in the GeoDataFrame.     The default is True. check_geotype : bool, optional     Check if the geometry is of the required type. The default is True.</p>"},{"location":"reference/hydamo/#hydamo_validation.datamodel.HyDAMO.from_geopackage--returns","title":"Returns","text":"<p>hydamo : HyDAMO     HyDAMO object initialized with content of GeoPackage</p> Source code in <code>hydamo_validation\\datamodel.py</code> <pre><code>@classmethod\ndef from_geopackage(\n    cls, file_path, version=\"2.2\", check_columns=True, check_geotype=True\n):\n    \"\"\"\n    Initialize HyDAMO class from GeoPackage\n\n    Parameters\n    ----------\n    file_path : path-string\n        Path-string to the hydamo GeoPackage\n    check_columns : bool, optional\n        Check if all required columns are present in the GeoDataFrame.\n        The default is True.\n    check_geotype : bool, optional\n        Check if the geometry is of the required type. The default is True.\n\n    Returns\n    -------\n    hydamo : HyDAMO\n        HyDAMO object initialized with content of GeoPackage\n\n    \"\"\"\n    hydamo = cls(version=version)\n    for layer in fiona.listlayers(file_path):\n        if layer in hydamo.layers:\n            hydamo_layer = getattr(hydamo, layer)\n            hydamo_layer.set_data(\n                gpd.read_file(file_path, layer=layer),\n                check_columns=check_columns,\n                check_geotype=check_geotype,\n            )\n    return hydamo\n</code></pre>"},{"location":"reference/hydamo/#hydamo_validation.datamodel.HyDAMO.get","title":"<code>get(layer, global_id)</code>","text":"<p>Get a DataFrame row (feature) providing a layer an global_id.</p>"},{"location":"reference/hydamo/#hydamo_validation.datamodel.HyDAMO.get--parameters","title":"Parameters","text":"<p>layer : str     DESCRIPTION. global_id : str     DESCRIPTION.</p>"},{"location":"reference/hydamo/#hydamo_validation.datamodel.HyDAMO.get--returns","title":"Returns","text":"<p>TYPE     DESCRIPTION.</p> Source code in <code>hydamo_validation\\datamodel.py</code> <pre><code>def get(self, layer: str, global_id: str):\n    \"\"\"\n    Get a DataFrame row (feature) providing a layer an global_id.\n\n    Parameters\n    ----------\n    layer : str\n        DESCRIPTION.\n    global_id : str\n        DESCRIPTION.\n\n    Returns\n    -------\n    TYPE\n        DESCRIPTION.\n\n    \"\"\"\n    return getattr(self, layer).set_index(\"globalid\").loc[global_id]\n</code></pre>"},{"location":"reference/hydamo/#hydamo_validation.datamodel.HyDAMO.init_datamodel","title":"<code>init_datamodel()</code>","text":"<p>Initialize DataModel from self.schemas_path.</p> Source code in <code>hydamo_validation\\datamodel.py</code> <pre><code>def init_datamodel(self) -&gt; None:\n    \"\"\"Initialize DataModel from self.schemas_path.\"\"\"\n    self.validation_schemas: dict[str, Any] = {}\n\n    # read schema as dict\n    with open(self.schema_json) as src:\n        schema = json.load(src)\n        hydamo_layers = [\n            Path(i[\"$ref\"]).name for i in schema[\"properties\"][\"HyDAMO\"][\"anyOf\"]\n        ]\n        self.layers = [i for i in hydamo_layers if i not in self.ignored_layers]\n\n    for hydamo_layer in self.layers:\n        definition = schema[\"definitions\"][hydamo_layer][\"properties\"]\n        layer_schema = map_definition(definition)\n        self.validation_schemas[hydamo_layer] = layer_schema\n\n        # add layer to data_model\n        geotype = next(\n            (i[\"dtype\"] for i in layer_schema if i[\"id\"] == \"geometry\"), None\n        )\n\n        required_columns = [\n            i[\"id\"]\n            for i in [i for i in layer_schema if \"required\" in i.keys()]\n            if i[\"required\"]\n        ]\n\n        setattr(\n            self,\n            hydamo_layer,\n            ExtendedGeoDataFrame(\n                validation_schema=layer_schema,\n                layer_name=hydamo_layer,\n                geotype=geotype,\n                required_columns=required_columns,\n            ),\n        )\n</code></pre>"},{"location":"reference/hydamo/#hydamo_validation.datamodel.HyDAMO.set_data","title":"<code>set_data(gdf, layer, index_col=None, check_columns=True, check_geotype=True, extra_attributes={})</code>","text":""},{"location":"reference/hydamo/#hydamo_validation.datamodel.HyDAMO.set_data--parameters","title":"Parameters","text":"<p>gdf : GeoDataFrame     GeoDataFrame with a HyDAMO object-layer layer : TYPE     HyDAMO layer to be set index_col : str, optional     Column to be used as index. The default is None. check_columns : bool, optional     Check if all required columns are present in the GeoDataFrame.     The default is True. check_geotype : bool, optional     Check if the geometry is of the required type. The default is True.</p>"},{"location":"reference/hydamo/#hydamo_validation.datamodel.HyDAMO.set_data--returns","title":"Returns","text":"<p>None.</p> Source code in <code>hydamo_validation\\datamodel.py</code> <pre><code>def set_data(\n    self,\n    gdf,\n    layer,\n    index_col=None,\n    check_columns=True,\n    check_geotype=True,\n    extra_attributes={},\n):\n    \"\"\"\n\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        GeoDataFrame with a HyDAMO object-layer\n    layer : TYPE\n        HyDAMO layer to be set\n    index_col : str, optional\n        Column to be used as index. The default is None.\n    check_columns : bool, optional\n        Check if all required columns are present in the GeoDataFrame.\n        The default is True.\n    check_geotype : bool, optional\n        Check if the geometry is of the required type. The default is True.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n\n    getattr(self, layer).set_data(\n        gdf,\n        index_col=index_col,\n        check_columns=check_columns,\n        check_geotype=check_geotype,\n        extra_attributes={},\n    )\n</code></pre>"},{"location":"reference/hydamo/#hydamo_validation.datamodel.HyDAMO.to_geopackage","title":"<code>to_geopackage(file_path, use_schema=True)</code>","text":""},{"location":"reference/hydamo/#hydamo_validation.datamodel.HyDAMO.to_geopackage--parameters","title":"Parameters","text":"<p>file_path : path-string     Path-string where the file should be written to use_schema : bool, optional     Use the schema to specify column-properties The default is True.</p>"},{"location":"reference/hydamo/#hydamo_validation.datamodel.HyDAMO.to_geopackage--returns","title":"Returns","text":"<p>None.</p> Source code in <code>hydamo_validation\\datamodel.py</code> <pre><code>def to_geopackage(self, file_path, use_schema=True):\n    \"\"\"\n\n    Parameters\n    ----------\n    file_path : path-string\n        Path-string where the file should be written to\n    use_schema : bool, optional\n        Use the schema to specify column-properties The default is True.\n\n    Returns\n    -------\n    None.\n\n    \"\"\"\n    file_path = Path(file_path)\n    for layer in self.layers:\n        gdf = getattr(self, layer).copy()\n        if not gdf.empty:\n            if use_schema:\n                # match fiona layer schema keys with gdf.columns\n                schema = getattr(self, layer)._get_schema()\n                schema_cols = list(schema[\"properties\"].keys()) + [\"geometry\"]\n                drop_cols = [i for i in gdf.columns if i not in schema_cols]\n                gdf.drop(columns=drop_cols, inplace=True)\n\n                schema[\"properties\"] = {\n                    k: v\n                    for k, v in schema[\"properties\"].items()\n                    if k in gdf.columns\n                }\n\n                # write gdf to geopackage, including schema\n                if gdf.index.name in gdf.columns:\n                    gdf.reset_index(drop=True, inplace=True)\n                gdf.to_file(\n                    file_path,\n                    layer=layer,\n                    driver=\"GPKG\",\n                    engine=\"pyogrio\",\n                )\n            else:\n                # write gdf to geopackage as is\n                if gdf.index.name in gdf.columns:\n                    gdf = gdf.reset_index(drop=True).copy()\n                gdf.to_file(file_path, layer=layer, driver=\"GPKG\", engine=\"pyogrio\")\n    if file_path.is_file():\n        add_styles_to_geopackage(file_path)\n</code></pre>"},{"location":"reference/logic_functions/","title":"Topologic functions","text":"<p>Logic functions to be used in eval-method.</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.BE","title":"<code>BE(gdf, parameter, min, max, inclusive=False)</code>","text":"<p>Evaluate if parameter-value is between min/max inclusive (true/false)</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.BE--parameters","title":"Parameters","text":"<p>gdf : GeoDataFrame     Input GeoDataFrame parameter: str     Input column with numeric values min : numeric     Lower limit of function max : numeric     Upper limit of function inclusive : bool, optional     To include min and max     The default is False.</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.BE--returns","title":"Returns","text":"<p>result : Series     Pandas Series (default dtype = bool)</p> Source code in <code>hydamo_validation\\functions\\logic.py</code> <pre><code>def BE(gdf, parameter, min, max, inclusive=False):\n    \"\"\"Evaluate if parameter-value is between min/max inclusive (true/false)\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        Input GeoDataFrame\n    parameter: str\n        Input column with numeric values\n    min : numeric\n        Lower limit of function\n    max : numeric\n        Upper limit of function\n    inclusive : bool, optional\n        To include min and max\n        The default is False.\n\n    Returns\n    -------\n    result : Series\n        Pandas Series (default dtype = bool)\n\n    \"\"\"\n    _check_attributes(gdf, [parameter, min, max])\n    if inclusive:\n        series = GE(gdf, parameter, min, dtype=bool) &amp; LE(\n            gdf, parameter, max, dtype=bool\n        )\n    else:\n        series = GT(gdf, parameter, min, dtype=bool) &amp; LT(\n            gdf, parameter, max, dtype=bool\n        )\n    return series\n</code></pre>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.EQ","title":"<code>EQ(gdf, left, right, dtype=bool)</code>","text":"<p>Evalate if left an right expression are equal</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.EQ--parameters","title":"Parameters","text":"<p>gdf : GeoDataFrame     Input GeoDataFrame left : str, numeric     Left column or value in expression right : TYPE     Right column or value in expression dtype : dtype, optional     dtype assigned to result Series     The default is bool.</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.EQ--returns","title":"Returns","text":"<p>result : Series     Pandas Series (default dtype = bool)</p> Source code in <code>hydamo_validation\\functions\\logic.py</code> <pre><code>def EQ(gdf, left, right, dtype=bool):\n    \"\"\"Evalate if left an right expression are equal\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        Input GeoDataFrame\n    left : str, numeric\n        Left column or value in expression\n    right : TYPE\n        Right column or value in expression\n    dtype : dtype, optional\n        dtype assigned to result Series\n        The default is bool.\n\n    Returns\n    -------\n    result : Series\n        Pandas Series (default dtype = bool)\n\n    \"\"\"\n    _check_attributes(gdf, [left, right])\n    expression = f\"{left} == {right}\".lower()\n    return gdf.eval(expression).astype(dtype)\n</code></pre>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.GE","title":"<code>GE(gdf, left, right, dtype=bool)</code>","text":"<p>Evaluate if left is greater or equal to/than right</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.GE--parameters","title":"Parameters","text":"<p>gdf : GeoDataFrame     Input GeoDataFrame left : str, numeric     Left column or value in expression right : TYPE     Right column or value in expression dtype : dtype, optional     dtype assigned to result Series     The default is bool.</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.GE--returns","title":"Returns","text":"<p>result : Series     Pandas Series (default dtype = bool)</p> Source code in <code>hydamo_validation\\functions\\logic.py</code> <pre><code>def GE(gdf, left, right, dtype=bool):\n    \"\"\"Evaluate if left is greater or equal to/than right\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        Input GeoDataFrame\n    left : str, numeric\n        Left column or value in expression\n    right : TYPE\n        Right column or value in expression\n    dtype : dtype, optional\n        dtype assigned to result Series\n        The default is bool.\n\n    Returns\n    -------\n    result : Series\n        Pandas Series (default dtype = bool)\n\n    \"\"\"\n    _check_attributes(gdf, [left, right])\n    expression = f\"{left} &gt;= {right}\".lower()\n    return gdf.eval(expression).astype(dtype)\n</code></pre>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.GT","title":"<code>GT(gdf, left, right, dtype=bool)</code>","text":"<p>Evaluate if left is greater than right</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.GT--parameters","title":"Parameters","text":"<p>gdf : GeoDataFrame     Input GeoDataFrame left : str, numeric     Left column or value in expression right : TYPE     Right column or value in expression dtype : dtype, optional     dtype assigned to result Series     The default is bool.</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.GT--returns","title":"Returns","text":"<p>result : Series     Pandas Series (default dtype = bool)</p> Source code in <code>hydamo_validation\\functions\\logic.py</code> <pre><code>def GT(gdf, left, right, dtype=bool):\n    \"\"\"\n    Evaluate if left is greater than right\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        Input GeoDataFrame\n    left : str, numeric\n        Left column or value in expression\n    right : TYPE\n        Right column or value in expression\n    dtype : dtype, optional\n        dtype assigned to result Series\n        The default is bool.\n\n    Returns\n    -------\n    result : Series\n        Pandas Series (default dtype = bool)\n\n    \"\"\"\n    _check_attributes(gdf, [left, right])\n    expression = f\"{left} &gt; {right}\".lower()\n    return gdf.eval(expression).astype(dtype)\n</code></pre>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.ISIN","title":"<code>ISIN(gdf, parameter, array)</code>","text":"<p>Evaluate if values in parameter are in array</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.ISIN--parameters","title":"Parameters","text":"<p>gdf : GeoDataFrame     Input GeoDataFrame parameter: str     Input column with numeric values array : list     list of possible values that return True</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.ISIN--returns","title":"Returns","text":"<p>result : Series     Pandas Series (default dtype = bool)</p> Source code in <code>hydamo_validation\\functions\\logic.py</code> <pre><code>def ISIN(gdf, parameter, array):\n    \"\"\"Evaluate if values in parameter are in array\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        Input GeoDataFrame\n    parameter: str\n        Input column with numeric values\n    array : list\n        list of possible values that return True\n\n    Returns\n    -------\n    result : Series\n        Pandas Series (default dtype = bool)\n\n    \"\"\"\n    _check_attributes(gdf, [parameter])\n    return gdf[parameter].isin(array)\n</code></pre>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.LE","title":"<code>LE(gdf, left, right, dtype=bool)</code>","text":"<p>Evaluate if left is less or equal to/than right</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.LE--parameters","title":"Parameters","text":"<p>gdf : GeoDataFrame     Input GeoDataFrame left : str, numeric     Left column or value in expression right : TYPE     Right column or value in expression dtype : dtype, optional     dtype assigned to result Series     The default is bool.</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.LE--returns","title":"Returns","text":"<p>result : Series     Pandas Series (default dtype = bool)</p> Source code in <code>hydamo_validation\\functions\\logic.py</code> <pre><code>def LE(gdf, left, right, dtype=bool):\n    \"\"\"\n    Evaluate if left is less or equal to/than right\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        Input GeoDataFrame\n    left : str, numeric\n        Left column or value in expression\n    right : TYPE\n        Right column or value in expression\n    dtype : dtype, optional\n        dtype assigned to result Series\n        The default is bool.\n\n    Returns\n    -------\n    result : Series\n        Pandas Series (default dtype = bool)\n\n    \"\"\"\n    _check_attributes(gdf, [left, right])\n    expression = f\"{left} &lt;= {right}\".lower()\n    return gdf.eval(expression).astype(dtype)\n</code></pre>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.LT","title":"<code>LT(gdf, left, right, dtype=bool)</code>","text":"<p>Evaluate if left is less than right</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.LT--parameters","title":"Parameters","text":"<p>gdf : GeoDataFrame     Input GeoDataFrame left : str, numeric     Left column or value in expression right : TYPE     Right column or value in expression dtype : dtype, optional     dtype assigned to result Series     The default is bool.</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.LT--returns","title":"Returns","text":"<p>result : Series     Pandas Series (default dtype = bool)</p> Source code in <code>hydamo_validation\\functions\\logic.py</code> <pre><code>def LT(gdf, left, right, dtype=bool):\n    \"\"\"\n    Evaluate if left is less than right\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        Input GeoDataFrame\n    left : str, numeric\n        Left column or value in expression\n    right : TYPE\n        Right column or value in expression\n    dtype : dtype, optional\n        dtype assigned to result Series\n        The default is bool.\n\n    Returns\n    -------\n    result : Series\n        Pandas Series (default dtype = bool)\n\n    \"\"\"\n    _check_attributes(gdf, [left, right])\n    expression = f\"{left} &lt; {right}\".lower()\n    return gdf.eval(expression).astype(dtype)\n</code></pre>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.NOTIN","title":"<code>NOTIN(gdf, parameter, array)</code>","text":"<p>Evaluate if values in parameter are not in array</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.NOTIN--parameters","title":"Parameters","text":"<p>gdf : GeoDataFrame     Input GeoDataFrame parameter: str     Input column with numeric values array : list     list of possible values that return False</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.NOTIN--returns","title":"Returns","text":"<p>result : Series     Pandas Series (default dtype = bool)</p> Source code in <code>hydamo_validation\\functions\\logic.py</code> <pre><code>def NOTIN(gdf, parameter, array):\n    \"\"\"Evaluate if values in parameter are not in array\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        Input GeoDataFrame\n    parameter: str\n        Input column with numeric values\n    array : list\n        list of possible values that return False\n\n    Returns\n    -------\n    result : Series\n        Pandas Series (default dtype = bool)\n\n    \"\"\"\n    _check_attributes(gdf, [parameter])\n    return ~ISIN(gdf, parameter, array)\n</code></pre>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.NOTNA","title":"<code>NOTNA(gdf, parameter)</code>","text":"<p>Evaluate if values in parameter ar not NaN or None</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.NOTNA--parameters","title":"Parameters","text":"<p>gdf : GeoDataFrame     Input GeoDataFrame parameter: str     Input column with numeric values</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.NOTNA--returns","title":"Returns","text":"<p>result : Series     Pandas Series (default dtype = bool)</p> Source code in <code>hydamo_validation\\functions\\logic.py</code> <pre><code>def NOTNA(gdf, parameter):\n    \"\"\"Evaluate if values in parameter ar not NaN or None\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        Input GeoDataFrame\n    parameter: str\n        Input column with numeric values\n\n    Returns\n    -------\n    result : Series\n        Pandas Series (default dtype = bool)\n\n    \"\"\"\n    _check_attributes(gdf, [parameter])\n    return gdf[parameter].notna()\n</code></pre>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.consistent_period","title":"<code>consistent_period(gdf, max_gap=1, groupers=['pompid', 'regelmiddelid'], priority='prioriteit', start_date='beginperiode', date_format='%d%m', end_date='eindperiode')</code>","text":"<p>Check if a periodic-based table is time-consistent</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.consistent_period--parameters","title":"Parameters","text":"<p>gdf : GeoDataFrame     Input GeoDataFrame max_gap: int     max gap in days between too adjacent periods</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.consistent_period--returns","title":"Returns","text":"<p>result : Series     Pandas Series (default dtype = bool)</p> Source code in <code>hydamo_validation\\functions\\logic.py</code> <pre><code>def consistent_period(\n    gdf,\n    max_gap=1,\n    groupers=[\"pompid\", \"regelmiddelid\"],\n    priority=\"prioriteit\",\n    start_date=\"beginperiode\",\n    date_format=\"%d%m\",\n    end_date=\"eindperiode\",\n):\n    \"\"\"Check if a periodic-based table is time-consistent\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        Input GeoDataFrame\n    max_gap: int\n        max gap in days between too adjacent periods\n\n    Returns\n    -------\n    result : Series\n        Pandas Series (default dtype = bool)\n\n    \"\"\"\n\n    # create an empty result\n    _gdf = gdf.copy()\n    result = pd.Series(index=_gdf.index)\n\n    # convert start_parameter and end_parameter to datetime\n    _gdf[start_date] = pd.to_datetime(_gdf[start_date], format=date_format)\n    _gdf[end_date] = pd.to_datetime(_gdf[end_date], format=date_format)\n\n    index_select = _gdf[start_date] &gt; _gdf[end_date]\n    _gdf.loc[index_select, end_date] = _gdf[index_select][\n        end_date\n    ] + pd.offsets.DateOffset(years=1)\n\n    for group in groupers:\n        grouper = _gdf.groupby(by=[group, \"prioriteit\"])\n\n        for _, df in _gdf.groupby(by=[\"pompid\", \"prioriteit\"]):\n            df.sort_values(by=start_date, inplace=True)\n\n            # check for overlap\n            bool_series = df.apply(\n                (lambda x: _overlapping_period(x, df, start_date, end_date)), axis=1\n            )\n\n            # check for gaps\n            gaps_series = df[start_date] - df.shift(1)[end_date]\n            gaps_series.iloc[0] = pd.Timedelta(days=0)  # due to shift we have NaT here\n\n            # add to result\n            bool_series = (gaps_series &lt;= pd.Timedelta(days=int(max_gap))) &amp; bool_series\n            bool_series = bool_series[\n                bool_series.index.isin(result[result.isna() | (result == True)].index)\n            ]\n            result.loc[result.index.isin(bool_series.index)] = bool_series\n\n    return result\n</code></pre>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.join_object_exists","title":"<code>join_object_exists(gdf, join_gdf, join_object)</code>","text":"<p>Evaluate if defined related_object id exists in globalid parameter of related object-table.</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.join_object_exists--parameters","title":"Parameters","text":"<p>gdf : GeoDataFrame     Input GeoDataFrame related_gdf : GeoDataFrame     Input GeoDataFrame with related objects object: str     HyDAMO object name of related object-layer</p>"},{"location":"reference/logic_functions/#hydamo_validation.logic_functions.join_object_exists--returns","title":"Returns","text":"<p>result : Series     Pandas Series (default dtype = bool)</p> Source code in <code>hydamo_validation\\functions\\logic.py</code> <pre><code>def join_object_exists(gdf, join_gdf, join_object):\n    \"\"\"Evaluate if defined related_object id exists in globalid parameter of\n    related object-table.\n\n    Parameters\n    ----------\n    gdf : GeoDataFrame\n        Input GeoDataFrame\n    related_gdf : GeoDataFrame\n        Input GeoDataFrame with related objects\n    object: str\n        HyDAMO object name of related object-layer\n\n    Returns\n    -------\n    result : Series\n        Pandas Series (default dtype = bool)\n\n    \"\"\"\n    _check_attributes(join_gdf, [\"globalid\"])\n    _check_attributes(gdf, [f\"{join_object}id\"])\n    return gdf[f\"{join_object}id\"].isin(join_gdf[\"globalid\"])\n</code></pre>"},{"location":"reference/topologic_functions/","title":"Topologic functions","text":"<p>Topologic functions executed on extended geodataframe.</p>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.compare_longitudinal","title":"<code>compare_longitudinal(gdf, datamodel, parameter, compare_object, compare_parameter, direction, logical_operator)</code>","text":"<p>Check if the value of a parameter in an object is lower/greater than an upstream/downstream value of another parameter from another object-layer.</p>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.compare_longitudinal--parameters","title":"Parameters","text":"<p>gdf : ExtendedGeoDataframe     ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO     HyDAMO datamodel class structures : str     List with structure-types to be expected on the boundary tolerance : numeric     Tolerance to determine if a structure is on a node</p>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.compare_longitudinal--returns","title":"Returns","text":"<p>Pandas Series     Default dtype is bool</p> Source code in <code>hydamo_validation\\functions\\topologic.py</code> <pre><code>def compare_longitudinal(\n    gdf,\n    datamodel,\n    parameter,\n    compare_object,\n    compare_parameter,\n    direction,\n    logical_operator,\n):\n    \"\"\"\n    Check if the value of a parameter in an object is lower/greater than an\n    upstream/downstream value of another parameter from another object-layer.\n\n\n    Parameters\n    ----------\n    gdf : ExtendedGeoDataframe\n        ExtendedGeoDataFrame, HyDAMO hydroobject layer\n    datamodel : HyDAMO\n        HyDAMO datamodel class\n    structures : str\n        List with structure-types to be expected on the boundary\n    tolerance : numeric\n        Tolerance to determine if a structure is on a node\n\n    Returns\n    -------\n    Pandas Series\n        Default dtype is bool\n\n    \"\"\"\n    branches = datamodel.hydroobject\n    compare_gdf = getattr(datamodel, compare_object)\n\n    # snap layers to to branches\n    geometry.find_nearest_branch(\n        branches=branches, geometries=compare_gdf, method=\"overall\"\n    )\n\n    geometry.find_nearest_branch(branches=branches, geometries=gdf, method=\"overall\")\n    return gdf.progress_apply(\n        lambda x: _compare_longitudinal(\n            x, parameter, compare_gdf, compare_parameter, direction, logical_operator\n        ),\n        axis=1,\n    ).astype(bool)\n</code></pre>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.distant_to_others","title":"<code>distant_to_others(gdf, datamodel, distance)</code>","text":"<p>Check if two objects are sufficient distant to other objects of the same layer.</p>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.distant_to_others--parameters","title":"Parameters","text":"<p>gdf : ExtendedGeoDataframe     ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO     HyDAMO datamodel class distance : numeric     Max distance to other node</p>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.distant_to_others--returns","title":"Returns","text":"<p>Pandas Series     Default dtype is bool</p> Source code in <code>hydamo_validation\\functions\\topologic.py</code> <pre><code>def distant_to_others(gdf, datamodel, distance):\n    \"\"\"\n    Check if two objects are sufficient distant to other objects of the same layer.\n\n    Parameters\n    ----------\n    gdf : ExtendedGeoDataframe\n        ExtendedGeoDataFrame, HyDAMO hydroobject layer\n    datamodel : HyDAMO\n        HyDAMO datamodel class\n    distance : numeric\n        Max distance to other node\n\n    Returns\n    -------\n    Pandas Series\n        Default dtype is bool\n\n    \"\"\"\n\n    sindex = gdf.sindex\n\n    return gdf.progress_apply(\n        lambda x: _distant_to_others(x, gdf, sindex, distance), axis=1\n    )\n</code></pre>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.geometry_length","title":"<code>geometry_length(gdf, datamodel, length, statistic='min', dtype=bool)</code>","text":"<p>Check if geometrie length is longer/shorter than a value</p>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.geometry_length--parameters","title":"Parameters","text":"<p>gdf : ExtendedGeoDataframe     ExtendedGeoDataFrame, typically a layer in a HyDAMO datamodel class datamodel : HyDAMO     HyDAMO datamodel class length : numeric     Length to compare the geometry length to statistic : str, options: 'min', 'max'     Use length as minimal or maximal length. Default is 'min' dtype : dtype, optional     Dtype to assign to the result series. The default is bool.</p>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.geometry_length--returns","title":"Returns","text":"<p>Pandas Series     Default dtype is bool</p> Source code in <code>hydamo_validation\\functions\\topologic.py</code> <pre><code>def geometry_length(\n    gdf, datamodel, length, statistic: Literal[\"min\", \"max\"] = \"min\", dtype=bool\n):\n    \"\"\"Check if geometrie length is longer/shorter than a value\n\n    Parameters\n    ----------\n    gdf : ExtendedGeoDataframe\n        ExtendedGeoDataFrame, typically a layer in a HyDAMO datamodel class\n    datamodel : HyDAMO\n        HyDAMO datamodel class\n    length : numeric\n        Length to compare the geometry length to\n    statistic : str, options: 'min', 'max'\n        Use length as minimal or maximal length. Default is 'min'\n    dtype : dtype, optional\n        Dtype to assign to the result series. The default is bool.\n\n    Returns\n    -------\n    Pandas Series\n        Default dtype is bool\n\n    \"\"\"\n    if statistic == \"min\":\n        series = gdf[\"geometry\"].length &gt;= length\n    elif statistic == \"max\":\n        series = gdf[\"geometry\"].length &lt;= length\n    return series.astype(dtype)\n</code></pre>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.no_dangling_node","title":"<code>no_dangling_node(gdf, datamodel, tolerance)</code>","text":"<p>Check if the end-node of a linestring object is not within tolerance of a start-node of another linestring object in the same layer.</p>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.no_dangling_node--parameters","title":"Parameters","text":"<p>gdf : ExtendedGeoDataframe     ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO     HyDAMO datamodel class tolerance : numeric     Max tolerance to determine if nodes are connected</p>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.no_dangling_node--returns","title":"Returns","text":"<p>Pandas Series     Default dtype is bool</p> Source code in <code>hydamo_validation\\functions\\topologic.py</code> <pre><code>def no_dangling_node(gdf, datamodel, tolerance):\n    \"\"\"Check if the end-node of a linestring object is not within tolerance of\n    a start-node of another linestring object in the same layer.\n\n    Parameters\n    ----------\n    gdf : ExtendedGeoDataframe\n        ExtendedGeoDataFrame, HyDAMO hydroobject layer\n    datamodel : HyDAMO\n        HyDAMO datamodel class\n    tolerance : numeric\n        Max tolerance to determine if nodes are connected\n\n    Returns\n    -------\n    Pandas Series\n        Default dtype is bool\n\n    \"\"\"\n    end_nodes_series = gdf[\"geometry\"].progress_apply(lambda x: Point(x.coords[-1]))\n    series = gdf[\"geometry\"].progress_apply(lambda x: Point(x.coords[0]))\n    sindex = series.sindex\n\n    return end_nodes_series.progress_apply(\n        lambda x: _intersects_end_node(x, series, sindex, tolerance)\n    )\n</code></pre>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.not_overlapping","title":"<code>not_overlapping(gdf, datamodel, tolerance)</code>","text":"<p>Check if an objects LineString geometry is not overlapping other object of the same layer.</p>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.not_overlapping--parameters","title":"Parameters","text":"<p>gdf : ExtendedGeoDataframe     ExtendedGeoDataFrame, typically a layer in a HyDAMO datamodel class datamodel : HyDAMO     HyDAMO datamodel class tolerance : numeric     Max tolerance for overlapping</p>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.not_overlapping--returns","title":"Returns","text":"<p>Pandas Series     Default dtype is bool</p> Source code in <code>hydamo_validation\\functions\\topologic.py</code> <pre><code>def not_overlapping(gdf, datamodel, tolerance):\n    \"\"\"Check if an objects LineString geometry is not overlapping other object\n    of the same layer.\n\n    Parameters\n    ----------\n    gdf : ExtendedGeoDataframe\n        ExtendedGeoDataFrame, typically a layer in a HyDAMO datamodel class\n    datamodel : HyDAMO\n        HyDAMO datamodel class\n    tolerance : numeric\n        Max tolerance for overlapping\n\n    Returns\n    -------\n    Pandas Series\n        Default dtype is bool\n\n    \"\"\"\n    sindex = gdf.sindex\n    if (gdf.geom_type == \"LineString\").all():\n        return gdf.progress_apply(\n            lambda x: _not_overlapping_line(x, gdf, sindex, tolerance), axis=1\n        )\n    elif (gdf.geom_type == \"Point\").all():\n        return gdf.progress_apply(\n            lambda x: _not_overlapping_point(x, gdf, sindex, tolerance), axis=1\n        )\n    else:\n        raise TypeError(\n            f\"GeoDataFrame has invalid geometry types: {gdf.geom_type.unique()}. Implemented for this function: [Point, LineString]\"\n        )\n</code></pre>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.snaps_to_hydroobject","title":"<code>snaps_to_hydroobject(gdf, datamodel, method, tolerance=0.001, dtype=bool)</code>","text":"<p>Check if geometries snap to HydroObject</p>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.snaps_to_hydroobject--parameters","title":"Parameters","text":"<p>gdf : ExtendedGeoDataframe     ExtendedGeoDataFrame, typically a layer in a HyDAMO datamodel class datamodel : HyDAMO     HyDAMO datamodel class method : str, options: 'intersecting', 'overal', 'centroid', 'ends'     Method that can be used to deterine nearest hydrobject tolerance : numeric     Tolerance used to snap to the hydroobjct dtype : dtype, optional     Dtype to assign to the result series. The default is bool.</p>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.snaps_to_hydroobject--returns","title":"Returns","text":"<p>Pandas Series     Default dtype is bool</p> Source code in <code>hydamo_validation\\functions\\topologic.py</code> <pre><code>def snaps_to_hydroobject(gdf, datamodel, method, tolerance=0.001, dtype=bool):\n    \"\"\"\n    Check if geometries snap to HydroObject\n\n    Parameters\n    ----------\n    gdf : ExtendedGeoDataframe\n        ExtendedGeoDataFrame, typically a layer in a HyDAMO datamodel class\n    datamodel : HyDAMO\n        HyDAMO datamodel class\n    method : str, options: 'intersecting', 'overal', 'centroid', 'ends'\n        Method that can be used to deterine nearest hydrobject\n    tolerance : numeric\n        Tolerance used to snap to the hydroobjct\n    dtype : dtype, optional\n        Dtype to assign to the result series. The default is bool.\n\n    Returns\n    -------\n    Pandas Series\n        Default dtype is bool\n\n    \"\"\"\n\n    branches = datamodel.hydroobject\n    geometry.find_nearest_branch(\n        branches=branches, geometries=gdf, method=method, maxdist=tolerance\n    )\n    series = ~gdf.branch_offset.isna()\n    return series.astype(dtype)\n</code></pre>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.splitted_at_junction","title":"<code>splitted_at_junction(gdf, datamodel, tolerance)</code>","text":"<p>Check if line is splitted when it can considered to be a junction</p>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.splitted_at_junction--parameters","title":"Parameters","text":"<p>gdf : ExtendedGeoDataframe     ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO     HyDAMO datamodel class tolerance : numeric     Max tolerance for junction nodes</p>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.splitted_at_junction--returns","title":"Returns","text":"<p>Pandas Series     Default dtype is bool</p> Source code in <code>hydamo_validation\\functions\\topologic.py</code> <pre><code>def splitted_at_junction(gdf, datamodel, tolerance):\n    \"\"\"Check if line is splitted when it can considered to be a junction\n\n    Parameters\n    ----------\n    gdf : ExtendedGeoDataframe\n        ExtendedGeoDataFrame, HyDAMO hydroobject layer\n    datamodel : HyDAMO\n        HyDAMO datamodel class\n    tolerance : numeric\n        Max tolerance for junction nodes\n\n    Returns\n    -------\n    Pandas Series\n        Default dtype is bool\n\n    \"\"\"\n    # get the nodes of the hydroobjects within tolerance\n    # nodes_series = _get_nodes(gdf, tolerance=None)\n    nodes_series = _get_nodes(gdf)\n\n    # check for lines if there are nodes on segment outside tolerance of\n    # the lines start-node and end-node.\n    sindex = nodes_series.sindex\n    return gdf.progress_apply(\n        (lambda x: _only_end_nodes(x, nodes_series, sindex, tolerance)), axis=1\n    )\n</code></pre>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.structures_at_boundaries","title":"<code>structures_at_boundaries(gdf, datamodel, areas, structures, tolerance, distance)</code>","text":"<p>Check if there are structures near area (typically water-level areas) boundaries.</p>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.structures_at_boundaries--parameters","title":"Parameters","text":"<p>gdf : ExtendedGeoDataframe     ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO     HyDAMO datamodel class areas : str     HyDAMO datamodel class with areas (\"peilgebiedenpraktijk\") structures : str     List with structure-types to be expected on the boundary tolerance : numeric     Tolerance to dermine if a structure is on the hydroobject distance : numeric     Max distance between structure and area-boundary</p>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.structures_at_boundaries--returns","title":"Returns","text":"<p>Pandas Series     Default dtype is bool</p> Source code in <code>hydamo_validation\\functions\\topologic.py</code> <pre><code>def structures_at_boundaries(gdf, datamodel, areas, structures, tolerance, distance):\n    \"\"\"\n    Check if there are structures near area (typically water-level areas) boundaries.\n\n    Parameters\n    ----------\n    gdf : ExtendedGeoDataframe\n        ExtendedGeoDataFrame, HyDAMO hydroobject layer\n    datamodel : HyDAMO\n        HyDAMO datamodel class\n    areas : str\n        HyDAMO datamodel class with areas (\"peilgebiedenpraktijk\")\n    structures : str\n        List with structure-types to be expected on the boundary\n    tolerance : numeric\n        Tolerance to dermine if a structure is on the hydroobject\n    distance : numeric\n        Max distance between structure and area-boundary\n\n    Returns\n    -------\n    Pandas Series\n        Default dtype is bool\n\n    \"\"\"\n\n    areas_gdf = getattr(datamodel, areas)\n    areas_sindex = areas_gdf.sindex\n\n    struc_series = _layers_from_datamodel(structures, datamodel)\n    struc_sindex = struc_series.sindex\n\n    return gdf.progress_apply(\n        lambda x: _structures_at_boundaries(\n            x, areas_gdf, areas_sindex, struc_series, struc_sindex, tolerance, distance\n        ),\n        axis=1,\n    )\n</code></pre>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.structures_at_intersections","title":"<code>structures_at_intersections(gdf, datamodel, structures, tolerance)</code>","text":"<p>Check if there are structures at intersections</p>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.structures_at_intersections--parameters","title":"Parameters","text":"<p>gdf : ExtendedGeoDataframe     ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO     HyDAMO datamodel class structures: str or list     HyDAMO structures to be expected at intersections     (\"stuw\", \"duikersifonhevel\") Presented as a string or list tolerance : numeric     Max tolerance for junction nodes</p>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.structures_at_intersections--returns","title":"Returns","text":"<p>Pandas Series     Default dtype is bool</p> Source code in <code>hydamo_validation\\functions\\topologic.py</code> <pre><code>def structures_at_intersections(gdf, datamodel, structures, tolerance):\n    \"\"\"Check if there are structures at intersections\n\n    Parameters\n    ----------\n    gdf : ExtendedGeoDataframe\n        ExtendedGeoDataFrame, HyDAMO hydroobject layer\n    datamodel : HyDAMO\n        HyDAMO datamodel class\n    structures: str or list\n        HyDAMO structures to be expected at intersections\n        (\"stuw\", \"duikersifonhevel\") Presented as a string or list\n    tolerance : numeric\n        Max tolerance for junction nodes\n\n    Returns\n    -------\n    Pandas Series\n        Default dtype is bool\n\n    \"\"\"\n    # make a geodataframe from structures list\n    struc_series = _layers_from_datamodel(structures, datamodel)\n    # create spatial indices\n    sindex = gdf.sindex\n    struc_sindex = struc_series.sindex\n    # return result\n    return gdf.progress_apply(\n        lambda x: _structures_at_intersections(\n            x, gdf, sindex, struc_series, struc_sindex, tolerance\n        ),\n        axis=1,\n    )\n</code></pre>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.structures_at_nodes","title":"<code>structures_at_nodes(gdf, datamodel, structures, tolerance)</code>","text":"<p>Check if structures are on boundary-nodes of lines (hydroobjects)</p>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.structures_at_nodes--parameters","title":"Parameters","text":"<p>gdf : ExtendedGeoDataframe     ExtendedGeoDataFrame, HyDAMO hydroobject layer datamodel : HyDAMO     HyDAMO datamodel class structures : str     List with structure-types to be expected on the boundary tolerance : numeric     Tolerance to determine if a structure is on a node</p>"},{"location":"reference/topologic_functions/#hydamo_validation.topologic_functions.structures_at_nodes--returns","title":"Returns","text":"<p>Pandas Series     Default dtype is bool</p> Source code in <code>hydamo_validation\\functions\\topologic.py</code> <pre><code>def structures_at_nodes(gdf, datamodel, structures, tolerance):\n    \"\"\"\n    Check if structures are on boundary-nodes of lines (hydroobjects)\n\n    Parameters\n    ----------\n    gdf : ExtendedGeoDataframe\n        ExtendedGeoDataFrame, HyDAMO hydroobject layer\n    datamodel : HyDAMO\n        HyDAMO datamodel class\n    structures : str\n        List with structure-types to be expected on the boundary\n    tolerance : numeric\n        Tolerance to determine if a structure is on a node\n\n    Returns\n    -------\n    Pandas Series\n        Default dtype is bool\n\n    \"\"\"\n    struc_series = _layers_from_datamodel(structures, datamodel)\n    struc_sindex = struc_series.sindex\n\n    return gdf[\"geometry\"].progress_apply(\n        lambda x: _no_struc_on_line(x, struc_series, struc_sindex, tolerance)\n    )\n</code></pre>"}]}